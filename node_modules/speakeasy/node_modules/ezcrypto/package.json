{
  "author": {
    "name": "Elmer Zhang",
    "email": "freeboy6716@gmail.com",
    "url": "http://www.elmerzhang.com/"
  },
  "name": "ezcrypto",
  "tags": [
    "Hash",
    "MD5",
    "SHA1",
    "SHA-1",
    "SHA256",
    "SHA-256",
    "RC4",
    "Rabbit",
    "AES",
    "DES",
    "PBKDF2",
    "HMAC",
    "OFB",
    "CFB",
    "CTR",
    "CBC",
    "Base64"
  ],
  "description": "Provide standard and secure cryptographic algorithms for NodeJS. Support MD5, SHA-1, SHA-256, RC4, Rabbit, AES, DES, PBKDF2, HMAC, OFB, CFB, CTR, CBC, Base64",
  "version": "0.0.3",
  "homepage": "https://github.com/ElmerZhang/ezcrypto",
  "repository": {
    "type": "git",
    "url": "git://github.com/ElmerZhang/ezcrypto.git"
  },
  "main": "index.js",
  "engines": {
    "node": "*"
  },
  "dependencies": {},
  "devDependencies": {},
  "readme": "**This module is modified from Crypto-JS: http://code.google.com/p/crypto-js/**\n\n**Crypto-JS is a growing collection of standard and secure cryptographic algorithms implemented in JavaScript using best practices and patterns. They are fast, and they have a consistent and simple interface.**\n\n#Quick-start Guide\n## Install\n<pre>\nnpm install ezcrypto\n</pre>\n## Examples\n###Start\n<pre>\nvar Crypto = require('ezcrypto').Crypto;\n</pre>\n###MD5\nMD5 is a widely used hash function. It's been used in a variety of security applications and is also commonly used to check the integrity of files. Though, MD5 is not collision resistant, and it isn't suitable for applications like SSL certificates or digital signatures that rely on this property.\n\n<pre>\nvar digest = Crypto.MD5(\"Message\");\nvar digestBytes = Crypto.MD5(\"Message\", { asBytes: true });\nvar digestString = Crypto.MD5(\"Message\", { asString: true });\n</pre>\n\n###SHA-1\nThe SHA hash functions were designed by the National Security Agency (NSA). SHA-1 is the most established of the existing SHA hash functions, and it's used in a variety of security applications and protocols. Though, SHA-1's collision resistance has been weakening as new attacks are discovered or improved.\n\n<pre>\nvar digest = Crypto.SHA1(\"Message\");\nvar digestBytes = Crypto.SHA1(\"Message\", { asBytes: true });\nvar digestString = Crypto.SHA1(\"Message\", { asString: true });\n</pre>\n\n###SHA-256\nSHA-256 is one of the three variants in the SHA-2 set. It isn't as widely used as SHA-1, though it appears to provide much better security.\n\n<pre>\nvar digest = Crypto.SHA256(\"Message\");\nvar digestBytes = Crypto.SHA256(\"Message\", { asBytes: true });\nvar digestString = Crypto.SHA256(\"Message\", { asString: true });\n</pre>\n\n###AES\nThe Advanced Encryption Standard (AES) is a U.S. Federal Information Processing Standard (FIPS). It was selected after a 5-year process where 15 competing designs were evaluated.\n\n<pre>\nvar crypted = Crypto.AES.encrypt(\"Message\", \"Secret Passphrase\");\nvar plain = Crypto.AES.decrypt(crypted, \"Secret Passphrase\");\n</pre>\nThanks to contributions from Simon Greatrix and Gergely Risko, Crypto-JS now includes a variety of modes of operation as well as padding schemes.\n\n<pre>\n// CBC with default padding scheme (iso7816)\nvar crypted = Crypto.AES.encrypt(\"Message\", \"Secret Passphrase\", { mode: new Crypto.mode.CBC });\nvar plain = Crypto.AES.decrypt(crypted, \"Secret Passphrase\", { mode: new Crypto.mode.CBC });\n\n// CBC with ansix923 padding scheme\nvar crypted = Crypto.AES.encrypt(\"Message\", \"Secret Passphrase\", { mode: new Crypto.mode.CBC(Crypto.pad.ansix923) });\nvar plain = Crypto.AES.decrypt(crypted, \"Secret Passphrase\", { mode: new Crypto.mode.CBC(Crypto.pad.ansix923) });\n</pre>\n\nThe modes of operation currently available are:\n* ECB\n* CBC\n* CFB\n* OFB\n* CTR\n\nAnd the padding schemes currently available are:\n* iso7816\n* ansix923\n* iso10126\n* pkcs7\n* ZeroPadding\n* NoPadding\n\n###DES\nThe Data Encryption Standard (DES) was selected as a U.S. Federal Information Processing Standard (FIPS) in 1976 and was widely used. Today it's considered insecure due to its small key size.\n\n<pre>\nvar crypted = Crypto.DES.encrypt(\"Message\", \"Secret Passphrase\");\nvar plain = Crypto.DES.decrypt(crypted, \"Secret Passphrase\");\n</pre>\n\nDES can use the same variety of modes of operation and padding schemes as AES.\n\nSpecial thanks to Simon Greatrix for contributing this DES implementation.\n\n###Rabbit\nRabbit is a high-performance stream cipher and a finalist in the eSTREAM Portfolio. It is one of the four designs selected after a 3 1/2-year process where 22 designs were evaluated.\n\n<pre>\nvar crypted = Crypto.Rabbit.encrypt(\"Message\", \"Secret Passphrase\");\nvar plain = Crypto.Rabbit.decrypt(crypted, \"Secret Passphrase\");\n</pre>\n\n###MARC4\nMARC4 (Modified Allegedly RC4) is based on RC4, a widely-used stream cipher. RC4 is used in popular protocols such as SSL and WEP. But though it's remarkable for its simplicity and speed, it has weaknesses. Crypto-JS provides a modified version that corrects these weaknesses, but the algorithm's history still doesn't inspire confidence in its security.\n\n<pre>\nvar crypted = Crypto.MARC4.encrypt(\"Message\", \"Secret Passphrase\");\nvar plain = Crypto.MARC4.decrypt(crypted, \"Secret Passphrase\");\n</pre>\n\n###HMAC\nKeyed-hash message authentication codes (HMAC) is a mechanism for message authentication using cryptographic hash functions. HMAC can be used in combination with any iterated cryptographic hash function.\n\n####HMAC-MD5\n\n<pre>\nvar hmac = Crypto.HMAC(Crypto.MD5, \"Message\", \"Secret Passphrase\");\nvar hmacBytes = Crypto.HMAC(Crypto.MD5, \"Message\", \"Secret Passphrase\", { asBytes: true });\nvar hmacString = Crypto.HMAC(Crypto.MD5, \"Message\", \"Secret Passphrase\", { asString: true });\n</pre>\n\n####HMAC-SHA1\n\n<pre>\nvar hmac = Crypto.HMAC(Crypto.SHA1, \"Message\", \"Secret Passphrase\");\nvar hmacBytes = Crypto.HMAC(Crypto.SHA1, \"Message\", \"Secret Passphrase\", { asBytes: true });\nvar hmacString = Crypto.HMAC(Crypto.SHA1, \"Message\", \"Secret Passphrase\", { asString: true });\n</pre>\n\n####HMAC-SHA256\n\n<pre>\nvar hmac = Crypto.HMAC(Crypto.SHA256, \"Message\", \"Secret Passphrase\");\nvar hmacBytes = Crypto.HMAC(Crypto.SHA256, \"Message\", \"Secret Passphrase\", { asBytes: true });\nvar hmacString = Crypto.HMAC(Crypto.SHA256, \"Message\", \"Secret Passphrase\", { asString: true });\n</pre>\n\n###PBKDF2\nPBKDF2 is a password-based key derivation function. In many applications of cryptography, user security is ultimately dependent on a password, and because a password usually can't be used directly as a cryptographic key, some processing is required.\n\nA salt provides a large set of keys for any given password, and an iteration count increases the cost of producing keys from a password, thereby also increasing the difficulty of attack.\n\n<pre>\nvar salt = Crypto.util.randomBytes(16);\n\nvar key128bit = Crypto.PBKDF2(\"Secret Passphrase\", salt, 16);\nvar key256bit = Crypto.PBKDF2(\"Secret Passphrase\", salt, 32);\nvar key512bit = Crypto.PBKDF2(\"Secret Passphrase\", salt, 64);\n\nvar key512bit1000 = Crypto.PBKDF2(\"Secret Passphrase\", salt, 64, { iterations: 1000 });\n</pre>\n\nPBKDF2 with a large iteration count can take a long time to compute. To avoid long-running script warnings, and thanks to contributions from Don Park, Crypto-JS provides an alternative version that executes asyncronously and passes the result to a callback. You also have the option to specify an onProgressChange callback that allows you to keep the user updated.\n\n<pre>\nvar salt = Crypto.util.randomBytes(16);\n\nfunction onCompleteHandler(result) {\n\t    document.getElementById('result').innerHTML = result;\n}\n\nfunction onProgressChangeHandler(percent) {\n\t    document.getElementById('progress').innerHTML = percent + '%';\n}\n\nCrypto.PBKDF2Async(\"Secret Passphrase\", salt, 64, onCompleteHandler, { iterations: 1000, onProgressChange: onProgressChangeHandler });\n</pre>\n\n###Utilities\n<pre>\nvar helloBytes = Crypto.charenc.Binary.stringToBytes(\"Hello, World!\");\nvar helloString = Crypto.charenc.Binary.bytesToString(helloBytes);\n\nvar utf8Bytes = Crypto.charenc.UTF8.stringToBytes(\"България\");\nvar unicodeString = Crypto.charenc.UTF8.bytesToString(utf8Bytes);\n\nvar helloHex = Crypto.util.bytesToHex(helloBytes);\nvar helloBytes = Crypto.util.hexToBytes(helloHex);\n\nvar helloBase64 = Crypto.util.bytesToBase64(helloBytes);\nvar helloBytes = Crypto.util.base64ToBytes(helloBase64);\n</pre>\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ElmerZhang/ezcrypto/issues"
  },
  "_id": "ezcrypto@0.0.3",
  "_shasum": "fd29cfb3a6cd8738f60a77f12c26aa4ff3c1f85e",
  "_from": "ezcrypto@0.0.3",
  "_resolved": "https://registry.npmjs.org/ezcrypto/-/ezcrypto-0.0.3.tgz"
}
